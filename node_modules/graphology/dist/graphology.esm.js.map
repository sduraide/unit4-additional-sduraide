{"version":3,"file":"graphology.esm.js","sources":["../src/utils.js","../src/errors.js","../src/data.js","../src/indices.js","../src/attributes.js","../src/iteration/edges.js","../src/iteration/neighbors.js","../src/iteration/adjacency.js","../src/serialization.js","../src/graph.js","../src/classes.js","../src/endpoint.esm.js"],"sourcesContent":["/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a Graph implementation instance.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function'\n  );\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' && value !== null && value.constructor === Object\n  );\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.directedSelfLoops = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\nDirectedNodeData.prototype.upgradeToMixed = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\nUndirectedNodeData.prototype.upgradeToMixed = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n","/**\n * Graphology Indexes Functions\n * =============================\n *\n * Bunch of functions used to compute or clear indexes.\n */\n\n/**\n * Function updating the 'structure' index with the given edge's data.\n * Note that in the case of the multi graph, related edges are stored in a\n * set that is the same for A -> B & B <- A.\n *\n * @param {Graph}    graph      - Target Graph instance.\n * @param {EdgeData} edgeData   - Added edge's data.\n * @param {NodeData} sourceData - Source node's data.\n * @param {NodeData} targetData - Target node's data.\n */\nexport function updateStructureIndex(\n  graph,\n  undirected,\n  edgeData,\n  source,\n  target,\n  sourceData,\n  targetData\n) {\n  const multi = graph.multi;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (undirected) outKey = inKey = 'undirected';\n\n  let adj, container;\n\n  if (multi) {\n    // Handling source\n    adj = sourceData[outKey];\n    container = adj[target];\n\n    if (typeof container === 'undefined') {\n      container = new Set();\n      adj[target] = container;\n    }\n\n    container.add(edgeData);\n\n    // If selfLoop, we break here\n    if (source === target && undirected) return;\n\n    // Handling target (we won't add the edge because it was already taken\n    // care of with source above)\n    adj = targetData[inKey];\n    if (typeof adj[source] === 'undefined') adj[source] = container;\n  } else {\n    // Handling source\n    sourceData[outKey][target] = edgeData;\n\n    // If selfLoop, we break here\n    if (source === target && undirected) return;\n\n    // Handling target\n    targetData[inKey][source] = edgeData;\n  }\n}\n\n/**\n * Function clearing the 'structure' index data related to the given edge.\n *\n * @param {Graph}    graph    - Target Graph instance.\n * @param {EdgeData} edgeData - Dropped edge's data.\n */\nexport function clearEdgeFromStructureIndex(graph, undirected, edgeData) {\n  const multi = graph.multi;\n\n  const {source: sourceData, target: targetData} = edgeData;\n\n  const source = sourceData.key,\n    target = targetData.key;\n\n  // NOTE: since the edge set is the same for source & target, we can only\n  // affect source\n  const outKey = undirected ? 'undirected' : 'out',\n    sourceIndex = sourceData[outKey];\n\n  const inKey = undirected ? 'undirected' : 'in';\n\n  if (target in sourceIndex) {\n    if (multi) {\n      const set = sourceIndex[target];\n\n      if (set.size === 1) {\n        delete sourceIndex[target];\n        delete targetData[inKey][source];\n      } else {\n        set.delete(edgeData);\n      }\n    } else delete sourceIndex[target];\n  }\n\n  if (multi) return;\n\n  const targetIndex = targetData[inKey];\n\n  delete targetIndex[source];\n}\n\n/**\n * Function clearing the whole 'structure' index.\n *\n * @param {Graph} graph - Target Graph instance.\n */\nexport function clearStructureIndex(graph) {\n  const iterator = graph._nodes.values();\n\n  let step;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    step.value.clear();\n  }\n}\n\n/**\n * Function used to upgrade a simple `structure` index to a multi on.\n *\n * @param {Graph}  graph - Target Graph instance.\n */\nexport function upgradeStructureIndexToMulti(graph) {\n  graph._nodes.forEach((data, node) => {\n    // Directed\n    if (data.out) {\n      for (const neighbor in data.out) {\n        const edges = new Set();\n        edges.add(data.out[neighbor]);\n        data.out[neighbor] = edges;\n        graph._nodes.get(neighbor).in[node] = edges;\n      }\n    }\n\n    // Undirected\n    if (data.undirected) {\n      for (const neighbor in data.undirected) {\n        if (neighbor > node) continue;\n\n        const edges = new Set();\n        edges.add(data.undirected[neighbor]);\n        data.undirected[neighbor] = edges;\n        graph._nodes.get(neighbor).undirected[node] = edges;\n      }\n    }\n  });\n}\n","/**\n * Graphology Attributes methods\n * ==============================\n *\n * Attributes-related methods being exactly the same for nodes & edges,\n * we abstract them here for factorization reasons.\n */\nimport {assign, isPlainObject, getMatchingEdge} from './utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributesMerger(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachAttributesMerger\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport function attachAttributesMethods(Graph) {\n  ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function collecting edges from the given object.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @return {array}         - The found edges.\n */\nfunction collectSimple(edges, object) {\n  for (const k in object) edges.push(object[k].key);\n}\n\nfunction collectMulti(edges, object) {\n  for (const k in object)\n    object[k].forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over edges from the given object using a callback.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n  }\n}\n\nfunction forEachMulti(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    object[k].forEach(edgeData =>\n      callback(\n        edgeData.key,\n        edgeData.attributes,\n        edgeData.source.key,\n        edgeData.target.key,\n        edgeData.source.attributes,\n        edgeData.target.attributes,\n        edgeData.undirected\n      )\n    );\n  }\n}\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction findSimple(object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction findMulti(object, callback, avoid) {\n  let iterator, step, edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    iterator = object[k].values();\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (shouldBreak) return edgeData.key;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object),\n    l = keys.length;\n\n  let inner = null,\n    i = 0;\n\n  return new Iterator(function next() {\n    let edgeData;\n\n    if (inner) {\n      const step = inner.next();\n\n      if (step.done) {\n        inner = null;\n        i++;\n        return next();\n      }\n\n      edgeData = step.value;\n    } else {\n      if (i >= l) return {done: true};\n\n      const k = keys[i];\n\n      if (k === avoid) {\n        i++;\n        return next();\n      }\n\n      edgeData = object[k];\n\n      if (edgeData instanceof Set) {\n        inner = edgeData.values();\n        return next();\n      }\n\n      i++;\n    }\n\n    return {\n      done: false,\n      value: {\n        edge: edgeData.key,\n        attributes: edgeData.attributes,\n        source: edgeData.source.key,\n        target: edgeData.target.key,\n        sourceAttributes: edgeData.source.attributes,\n        targetAttributes: edgeData.target.attributes,\n        undirected: edgeData.undirected\n      }\n    };\n  });\n}\n\n/**\n * Function collecting edges from the given object at given key.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @param  {mixed}  k      - Neighbor key.\n * @return {array}         - The found edges.\n */\nfunction collectForKeySimple(edges, object, k) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  edges.push(edgeData.key);\n}\n\nfunction collectForKeyMulti(edges, object, k) {\n  const edgesData = object[k];\n\n  if (!edgesData) return;\n\n  edgesData.forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  callback(\n    edgeData.key,\n    edgeData.attributes,\n    sourceData.key,\n    targetData.key,\n    sourceData.attributes,\n    targetData.attributes,\n    edgeData.undirected\n  );\n}\n\nfunction forEachForKeyMulti(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData) return;\n\n  edgesData.forEach(edgeData =>\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    )\n  );\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction findForKeySimple(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    )\n  )\n    return edgeData.key;\n}\n\nfunction findForKeyMulti(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData) return;\n\n  let shouldBreak = false;\n\n  const iterator = edgesData.values();\n  let step, edgeData;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    edgeData = step.value;\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  const v = object[k];\n\n  if (v instanceof Set) {\n    const iterator = v.values();\n\n    return new Iterator(function () {\n      const step = iterator.next();\n\n      if (step.done) return step;\n\n      const edgeData = step.value;\n\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    });\n  }\n\n  return Iterator.of([\n    v.key,\n    v.attributes,\n    v.source.key,\n    v.target.key,\n    v.source.attributes,\n    v.target.attributes\n  ]);\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    if (typeof Array.from === 'function')\n      return Array.from(graph._edges.keys());\n\n    return take(graph._edges.keys(), graph._edges.size);\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n  }\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction findEdge(graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return Iterator.empty();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    let step, data;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      step = iterator.next();\n\n      if (step.done) return step;\n\n      data = step.value;\n\n      if (shouldFilter && data.undirected !== mask) continue;\n\n      break;\n    }\n\n    const value = {\n      edge: data.key,\n      attributes: data.attributes,\n      source: data.source.key,\n      target: data.target.key,\n      sourceAttributes: data.source.attributes,\n      targetAttributes: data.target.attributes,\n      undirected: data.undirected\n    };\n\n    return {value, done: false};\n  });\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = [];\n\n  const fn = multi ? collectMulti : collectSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') fn(edges, nodeData.in);\n    if (direction !== 'in') fn(edges, nodeData.out);\n\n    // Handling self loop edge case\n    if (!direction && nodeData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(nodeData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    fn(edges, nodeData.undirected);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') fn(nodeData.in, callback);\n    if (direction !== 'in')\n      fn(nodeData.out, callback, !direction ? nodeData.key : null);\n  }\n\n  if (type !== 'directed') {\n    fn(nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction findEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? findMulti : findSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(nodeData.in, callback);\n\n      if (found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(nodeData.out, callback, !direction ? nodeData.key : null);\n\n      if (found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(nodeData.undirected, callback);\n\n    if (found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : null)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const fn = multi ? collectForKeyMulti : collectForKeySimple;\n\n  const edges = [];\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(edges, sourceData.in, target);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      fn(edges, sourceData.out, target);\n\n    // Handling self loop edge case\n    if (!direction && sourceData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(sourceData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(edges, sourceData.undirected, target);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over edges for the given path using a callback.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(sourceData.in, target, callback);\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n        fn(sourceData.out, target, callback);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(sourceData.undirected, target, callback);\n  }\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction findEdgeForPath(type, multi, direction, sourceData, target, callback) {\n  const fn = multi ? findForKeyMulti : findForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(sourceData.in, target, callback);\n\n      if (found) return found;\n    }\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in') {\n        found = fn(\n          sourceData.out,\n          target,\n          callback,\n          !direction ? sourceData.key : null\n        );\n\n        if (found) return found;\n      }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(sourceData.undirected, target, callback);\n\n      if (found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return findEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return findEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return findEdgeForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {NotFoundGraphError, InvalidArgumentsGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function merging neighbors into the given set iterating over the given object.\n *\n * @param {BasicSet} neighbors - Neighbors set.\n * @param {object}   object    - Target object.\n */\nfunction merge(neighbors, object) {\n  if (typeof object === 'undefined') return;\n\n  for (const neighbor in object) neighbors.add(neighbor);\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const neighbors = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      merge(neighbors, nodeData.in);\n    }\n    if (direction !== 'in') {\n      merge(neighbors, nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    merge(neighbors, nodeData.undirected);\n  }\n\n  return take(neighbors.values(), neighbors.size);\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    callback(neighborData.key, neighborData.attributes);\n  }\n}\n\nfunction forEachInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key)) continue;\n\n    visited.add(neighborData.key);\n\n    callback(neighborData.key, neighborData.attributes);\n  }\n}\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction findInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction findInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key)) continue;\n\n    visited.add(neighborData.key);\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighborForNode(type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      forEachInObjectOnce(visited, nodeData, nodeData.in, callback);\n    }\n    if (direction !== 'in') {\n      forEachInObjectOnce(visited, nodeData, nodeData.out, callback);\n    }\n  }\n\n  if (type !== 'directed') {\n    forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n  }\n}\n\nfunction findNeighbor(type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return findInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return findInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = findInObjectOnce(visited, nodeData, nodeData.in, callback);\n\n      if (found) return found;\n    }\n    if (direction !== 'in') {\n      found = findInObjectOnce(visited, nodeData, nodeData.out, callback);\n\n      if (found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = findInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n\n    if (found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createObjectIterator(nodeData, object) {\n  const keys = Object.keys(object),\n    l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    return {\n      done: false,\n      value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n    };\n  });\n}\n\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object),\n    l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    if (i >= l) return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n      targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key)) return next();\n\n    visited.add(neighborData.key);\n\n    return {\n      done: false,\n      value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createObjectIterator(nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createObjectIterator(nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighborForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return findNeighbor(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Adjacency Iteration\n * ================================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\nimport Iterator from 'obliterator/iterator';\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable - Can we break?\n * @param {Graph}    graph     - Target Graph instance.\n * @param {callback} function  - Iteration callback.\n */\nexport function forEachAdjacencySimple(breakable, graph, callback) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected\n        );\n\n        if (breakable && shouldBreak) return edgeData.key;\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        if (targetData.key !== neighbor) targetData = edgeData.source;\n\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected\n        );\n\n        if (breakable && shouldBreak) return edgeData.key;\n      }\n    }\n  }\n\n  return;\n}\n\n/**\n * Function iterating over a multi graph's adjacency using a callback.\n *\n * @param {boolean}  breakable - Can we break?\n * @param {Graph}    graph    - Target Graph instance.\n * @param {callback} function - Iteration callback.\n */\nexport function forEachAdjacencyMulti(breakable, graph, callback) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step,\n    sourceData,\n    neighbor,\n    container,\n    containerStep,\n    adj,\n    edgeData,\n    targetData,\n    shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        container = adj[neighbor].values();\n\n        while (\n          ((containerStep = container.next()), containerStep.done !== true)\n        ) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData.key;\n        }\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        container = adj[neighbor].values();\n\n        while (\n          ((containerStep = container.next()), containerStep.done !== true)\n        ) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData.key;\n        }\n      }\n    }\n  }\n\n  return;\n}\n\nexport function createAdjacencyIteratorSimple(graph) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let state = 'outer',\n    sourceData,\n    neighbors,\n    adj,\n    offset;\n\n  return new Iterator(function next() {\n    let step;\n\n    if (state === 'outer') {\n      step = iterator.next();\n\n      if (step.done === true) return step;\n\n      sourceData = step.value;\n\n      state = 'directed';\n      return next();\n    }\n\n    if (state === 'directed') {\n      if (type === 'undirected') {\n        state = 'undirected';\n        return next();\n      }\n\n      adj = sourceData.out;\n      neighbors = Object.keys(sourceData.out);\n      offset = 0;\n      state = 'inner-directed';\n\n      return next();\n    }\n\n    if (state === 'undirected') {\n      if (type === 'directed') {\n        state = 'outer';\n        return next();\n      }\n\n      adj = sourceData.undirected;\n      neighbors = Object.keys(sourceData.undirected);\n      offset = 0;\n      state = 'inner-undirected';\n    }\n\n    // Inner\n    if (offset >= neighbors.length) {\n      if (state === 'inner-undirected') state = 'outer';\n      else state = 'undirected';\n\n      return next();\n    }\n\n    const neighbor = neighbors[offset++];\n    const edgeData = adj[neighbor];\n    let targetData = edgeData.target;\n\n    if (state === 'inner-undirected' && targetData.key === sourceData.key)\n      targetData = edgeData.source;\n\n    return {\n      done: false,\n      value: {\n        source: sourceData.key,\n        target: targetData.key,\n        sourceAttributes: sourceData.attributes,\n        targetAttributes: targetData.attributes,\n        edgeKey: edgeData.key,\n        edgeAttributes: edgeData.attributes,\n        undirected: edgeData.undirected\n      }\n    };\n  });\n}\n\nexport function createAdjacencyIteratorMulti(graph) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let state = 'outer',\n    sourceData,\n    neighbors,\n    container = null,\n    adj,\n    offset;\n\n  return new Iterator(function next() {\n    let step;\n\n    if (state === 'outer') {\n      step = iterator.next();\n\n      if (step.done === true) return step;\n\n      sourceData = step.value;\n\n      state = 'directed';\n      return next();\n    }\n\n    if (state === 'directed') {\n      if (type === 'undirected') {\n        state = 'undirected';\n        return next();\n      }\n\n      adj = sourceData.out;\n      neighbors = Object.keys(sourceData.out);\n      offset = 0;\n      state = 'inner-directed';\n\n      return next();\n    }\n\n    if (state === 'undirected') {\n      if (type === 'directed') {\n        state = 'outer';\n        return next();\n      }\n\n      adj = sourceData.undirected;\n      neighbors = Object.keys(sourceData.undirected);\n      offset = 0;\n      state = 'inner-undirected';\n    }\n\n    // Inner\n    if (!container && offset >= neighbors.length) {\n      if (state === 'inner-undirected') state = 'outer';\n      else state = 'undirected';\n\n      return next();\n    }\n\n    if (!container) {\n      const neighbor = neighbors[offset++];\n      container = adj[neighbor].values();\n      return next();\n    }\n\n    step = container.next();\n\n    if (step.done) {\n      container = null;\n      return next();\n    }\n\n    const edgeData = step.value;\n    let targetData = edgeData.target;\n\n    if (state === 'inner-undirected' && targetData.key === sourceData.key)\n      targetData = edgeData.source;\n\n    return {\n      done: false,\n      value: {\n        source: sourceData.key,\n        target: targetData.key,\n        sourceAttributes: sourceData.attributes,\n        targetAttributes: targetData.attributes,\n        edge: edgeData.key,\n        edgeAttributes: edgeData.attributes,\n        undirected: edgeData.undirected\n      }\n    };\n  });\n}\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used to validate import-export formats & to ouput\n * them from internal graph data.\n *\n * Serialized Node:\n * {key, ?attributes}\n *\n * Serialized Edge:\n * {key?, source, target, attributes?, undirected?}\n *\n * Serialized Graph:\n * {nodes[], edges?[]}\n */\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value)) return 'not-object';\n\n  if (!('key' in value)) return 'no-key';\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    return 'invalid-attributes';\n\n  return null;\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value)) return 'not-object';\n\n  if (!('source' in value)) return 'no-source';\n\n  if (!('target' in value)) return 'no-target';\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    return 'invalid-attributes';\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    return 'invalid-undirected';\n\n  return null;\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport {\n  updateStructureIndex,\n  clearEdgeFromStructureIndex,\n  clearStructureIndex,\n  upgradeStructureIndexToMulti\n} from './indices';\n\nimport {attachAttributesMethods} from './attributes';\nimport {attachEdgeIterationMethods} from './iteration/edges';\nimport {attachNeighborIterationMethods} from './iteration/neighbors';\nimport {\n  forEachAdjacencySimple,\n  forEachAdjacencyMulti,\n  createAdjacencyIteratorSimple,\n  createAdjacencyIteratorMulti\n} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isGraph,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalIdStartingFromRandomByte,\n  validateHints\n} from './utils';\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    } else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  } else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    } else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target),\n    edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are coherent\n      if (\n        edgeData.source.key !== source ||\n        edgeData.target.key !== target ||\n        (undirected &&\n          (edgeData.source.key !== target || edgeData.target.key !== source))\n      ) {\n        throw new UsageGraphError(\n          `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n        );\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return alreadyExistingEdgeData.key;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return alreadyExistingEdgeData.key;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n\n    if (source === target) targetData = sourceData;\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    } else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  } else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    } else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instanceId = INSTANCE_ID();\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = 'geid_' + instanceId + '_' + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.out[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.undirected[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n\n      if (!edges)\n        edges =\n          typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.directedSelfLoops;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree + nodeData.directedSelfLoops;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    const loops = nodeData.directedSelfLoops;\n\n    const inDegree = nodeData.inDegree + loops;\n    const outDegree = nodeData.outDegree + loops;\n\n    return inDegree + outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    const loops = nodeData.undirectedSelfLoops;\n\n    return nodeData.undirectedDegree + loops * 2;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree + nodeData.undirectedSelfLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree +=\n        nodeData.inDegree + nodeData.outDegree + nodeData.directedSelfLoops * 2;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key,\n      target = data.target.key;\n\n    if (node !== source && node !== target)\n      throw new NotFoundGraphError(\n        `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n      );\n\n    return node === source ? target : source;\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return node;\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return node;\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Removing attached edges\n    // TODO: we could do faster\n    this.forEachEdge(node, edge => {\n      this.dropEdge(edge);\n    });\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0],\n        target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    // Dropping the edge from the register\n    this._edges.delete(edgeData.key);\n\n    // Updating related degrees\n    const {source: sourceData, target: targetData, attributes} = edgeData;\n\n    const undirected = edgeData.undirected;\n\n    if (sourceData === targetData) {\n      if (undirected) {\n        sourceData.undirectedSelfLoops--;\n        this._undirectedSelfLoopCount--;\n      } else {\n        sourceData.directedSelfLoops--;\n        this._directedSelfLoopCount--;\n      }\n    } else {\n      if (undirected) {\n        sourceData.undirectedDegree--;\n        targetData.undirectedDegree--;\n      } else {\n        sourceData.outDegree--;\n        targetData.inDegree--;\n      }\n    }\n\n    // Clearing index\n    clearEdgeFromStructureIndex(this, undirected, edgeData);\n\n    if (undirected) this._undirectedSize--;\n    else this._directedSize--;\n\n    // Emitting\n    this.emit('edgeDropped', {\n      key: edge,\n      attributes,\n      source: sourceData.key,\n      target: targetData.key,\n      undirected\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    clearStructureIndex(this);\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method returning the desired attribute for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to get.\n   * @return {any}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.getNodeAttribute: could not find the \"${node}\" node in the graph.`\n      );\n\n    return data.attributes[name];\n  }\n\n  /**\n   * Method returning the attributes for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @return {object}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttributes(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.getNodeAttributes: could not find the \"${node}\" node in the graph.`\n      );\n\n    return data.attributes;\n  }\n\n  /**\n   * Method checking whether the given attribute exists for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to check.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  hasNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasNodeAttribute: could not find the \"${node}\" node in the graph.`\n      );\n\n    return data.attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to set.\n   * @param  {any}    value - Value for the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  setNodeAttribute(node, name, value) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.setNodeAttribute: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        \"Graph.setNodeAttribute: not enough arguments. Either you forgot to pass the attribute's name or value, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.\"\n      );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}      node    - Target node.\n   * @param  {string}   name    - Name of the attribute to set.\n   * @param  {function} updater - Function that will update the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if updater is not a function.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  updateNodeAttribute(node, name, updater) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.updateNodeAttribute: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        \"Graph.updateNodeAttribute: not enough arguments. Either you forgot to pass the attribute's name or updater, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.\"\n      );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to remove.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  removeNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.removeNodeAttribute: could not find the \"${node}\" node in the graph.`\n      );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method completely replacing the attributes of the given node.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  replaceNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.replaceNodeAttributes: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceNodeAttributes: provided attributes are not a plain object.'\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the attributes of the given node with the provided ones.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  mergeNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.mergeNodeAttributes: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeNodeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      edgeData.attributes = updater(edgeData.key, edgeData.attributes);\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEach(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEach: expecting a callback.'\n      );\n\n    if (this.multi) forEachAdjacencyMulti(false, this, callback);\n    else forEachAdjacencySimple(false, this, callback);\n  }\n\n  /**\n   * Method returning whether a matching edge can be found using given\n   * predicate function.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  find(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.find: expecting a callback.');\n\n    if (this.multi) return forEachAdjacencyMulti(true, this, callback);\n\n    return forEachAdjacencySimple(true, this, callback);\n  }\n\n  /**\n   * Method returning an iterator over the graph's adjacency.\n   *\n   * @return {Iterator}\n   */\n  adjacency() {\n    if (this.multi) return createAdjacencyIteratorMulti(this);\n\n    return createAdjacencyIteratorSimple(this);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    if (typeof Array.from === 'function') return Array.from(this._nodes.keys());\n\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done) return step;\n\n      const data = step.value;\n\n      return {\n        value: {node: data.key, attributes: data.attributes},\n        done: false\n      };\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method exporting the target node.\n   *\n   * @param  {any}   node - Target node.\n   * @return {array}      - The serialized node.\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  exportNode(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.exportNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    return serializeNode(node, data);\n  }\n\n  /**\n   * Method exporting the target edge.\n   *\n   * @param  {any}   edge - Target edge.\n   * @return {array}      - The serialized edge.\n   *\n   * @throws {Error} - Will throw if the edge is not found.\n   */\n  exportEdge(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.exportEdge: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return serializeEdge(edge, data);\n  }\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(key, data);\n    });\n\n    return {\n      attributes: this.getAttributes(),\n      nodes,\n      edges,\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      }\n    };\n  }\n\n  /**\n   * Method used to import a serialized node.\n   *\n   * @param  {object} data   - The serialized node.\n   * @param  {boolean} merge - Whether to merge the given node.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importNode(data, merge = false) {\n    // Validating\n    const error = validateSerializedNode(data);\n\n    if (error) {\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n        );\n      if (error === 'no-key')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importNode: no key provided.'\n        );\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.'\n        );\n    }\n\n    // Adding the node\n    const {key, attributes = {}} = data;\n\n    if (merge) this.mergeNode(key, attributes);\n    else this.addNode(key, attributes);\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized edge.\n   *\n   * @param  {object}  data  - The serialized edge.\n   * @param  {boolean} merge - Whether to merge the given edge.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importEdge(data, merge = false) {\n    // Validating\n    const error = validateSerializedEdge(data);\n\n    if (error) {\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n        );\n      if (error === 'no-source')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: missing souce.'\n        );\n      if (error === 'no-target')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: missing target.'\n        );\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.'\n        );\n      if (error === 'invalid-undirected')\n        throw new InvalidArgumentsGraphError(\n          'Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.'\n        );\n    }\n\n    // Adding the edge\n    const {source, target, attributes = {}, undirected = false} = data;\n\n    let method;\n\n    if ('key' in data) {\n      method = merge\n        ? undirected\n          ? this.mergeUndirectedEdgeWithKey\n          : this.mergeDirectedEdgeWithKey\n        : undirected\n        ? this.addUndirectedEdgeWithKey\n        : this.addDirectedEdgeWithKey;\n\n      method.call(this, data.key, source, target, attributes);\n    } else {\n      method = merge\n        ? undirected\n          ? this.mergeUndirectedEdge\n          : this.mergeDirectedEdge\n        : undirected\n        ? this.addUndirectedEdge\n        : this.addDirectedEdge;\n\n      method.call(this, source, target, attributes);\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance\n    if (isGraph(data)) {\n      this.import(data.export(), merge);\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) this.importNode(list[i], merge);\n    }\n\n    if (data.edges) {\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) this.importEdge(list[i], merge);\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    return new Graph(assign({}, this._options, options));\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @return {Graph} - The copy.\n   */\n  copy() {\n    const graph = this.emptyCopy();\n\n    this.forEachEdge((edge, attr, source, target, _sa, _ta, undirected) => {\n      addEdge(\n        graph,\n        'copy',\n        false,\n        undirected,\n        edge,\n        source,\n        target,\n        assign({}, attr)\n      );\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method upgrading the graph to a mixed one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMixed() {\n    if (this.type === 'mixed') return this;\n\n    // Upgrading node data:\n    // NOTE: maybe this could lead to some de-optimization by usual\n    // JavaScript engines but I cannot be sure of it. Another solution\n    // would be to reinstantiate the classes but this surely has a performance\n    // and memory impact.\n    this._nodes.forEach(data => data.upgradeToMixed());\n\n    // Mutating the options & the instance\n    this._options.type = 'mixed';\n    readOnlyProperty(this, 'type', this._options.type);\n    privateProperty(this, 'NodeDataClass', MixedNodeData);\n\n    return this;\n  }\n\n  /**\n   * Method upgrading the graph to a multi one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMulti() {\n    if (this.multi) return this;\n\n    // Mutating the options & the instance\n    this._options.multi = true;\n    readOnlyProperty(this, 'multi', true);\n\n    // Upgrading indices\n    upgradeStructureIndexToMulti(this);\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Self iterator.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.iterator] = Graph.prototype.adjacency;\n\n/**\n * Attributes-related.\n */\nattachAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n","/**\n * Graphology ESM Endoint\n * =======================\n *\n * Endpoint for ESM modules consumers.\n */\nimport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n} from './classes';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nexport default Graph;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph,\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n};\n"],"names":[],"mappings":"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"}