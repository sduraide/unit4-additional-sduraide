/// <reference types="node" />
/**
 * Sigma.js
 * ========
 * @module
 */
import { EventEmitter } from "events";
import Graph from "graphology";
import Camera from "./core/camera";
import MouseCaptor from "./core/captors/mouse";
import { CameraState, Coordinates, Dimensions, EdgeDisplayData, Extent, NodeDisplayData } from "./types";
import { Settings } from "./settings";
import TouchCaptor from "./core/captors/touch";
/**
 * Main class.
 *
 * @constructor
 * @param {Graph}       graph     - Graph to render.
 * @param {HTMLElement} container - DOM container in which to render.
 * @param {object}      settings  - Optional settings.
 */
export default class Sigma extends EventEmitter {
    private settings;
    private graph;
    private mouseCaptor;
    private touchCaptor;
    private container;
    private elements;
    private canvasContexts;
    private webGLContexts;
    private activeListeners;
    private quadtree;
    private labelGrid;
    private nodeDataCache;
    private edgeDataCache;
    private nodeKeyToIndex;
    private edgeKeyToIndex;
    private nodeExtent;
    private matrix;
    private invMatrix;
    private customBBox;
    private normalizationFunction;
    private cameraSizeRatio;
    private width;
    private height;
    private displayedLabels;
    private highlightedNodes;
    private hoveredNode;
    private renderFrame;
    private renderHighlightedNodesFrame;
    private needToProcess;
    private needToSoftProcess;
    private nodePrograms;
    private hoverNodePrograms;
    private edgePrograms;
    private camera;
    constructor(graph: Graph, container: HTMLElement, settings?: Partial<Settings>);
    /**---------------------------------------------------------------------------
     * Internal methods.
     **---------------------------------------------------------------------------
     */
    /**
     * Internal function used to create a canvas element.
     * @param  {string} id - Context's id.
     * @return {Sigma}
     */
    private createCanvas;
    /**
     * Internal function used to create a canvas context and add the relevant
     * DOM elements.
     *
     * @param  {string} id - Context's id.
     * @return {Sigma}
     */
    private createCanvasContext;
    /**
     * Internal function used to create a canvas context and add the relevant
     * DOM elements.
     *
     * @param  {string} id - Context's id.
     * @return {Sigma}
     */
    private createWebGLContext;
    /**
     * Method used to initialize display data cache.
     *
     * @return {Sigma}
     */
    private initializeCache;
    /**
     * Method binding camera handlers.
     *
     * @return {Sigma}
     */
    private bindCameraHandlers;
    /**
     * Method binding event handlers.
     *
     * @return {Sigma}
     */
    private bindEventHandlers;
    /**
     * Method binding graph handlers
     *
     * @return {Sigma}
     */
    private bindGraphHandlers;
    /**
     * Method used to process the whole graph's data.
     *
     * @return {Sigma}
     */
    private process;
    /**
     * Method that decides whether to reprocess graph or not, and then render the
     * graph.
     *
     * @return {Sigma}
     */
    private _refresh;
    /**
     * Method that schedules a `_refresh` call if none has been scheduled yet. It
     * will then be processed next available frame.
     *
     * @return {Sigma}
     */
    private _scheduleRefresh;
    /**
     * Method used to render labels.
     *
     * @return {Sigma}
     */
    private renderLabels;
    /**
     * Method used to render edge labels, based on which node labels were
     * rendered.
     *
     * @return {Sigma}
     */
    private renderEdgeLabels;
    /**
     * Method used to render the highlighted nodes.
     *
     * @return {Sigma}
     */
    private renderHighlightedNodes;
    /**
     * Method used to schedule a hover render.
     *
     */
    private scheduleHighlightedNodesRender;
    /**
     * Method used to render.
     *
     * @return {Sigma}
     */
    private render;
    /**
     * Internal method used to update expensive and therefore cached values
     * each time the camera state is updated.
     */
    private updateCachedValues;
    /**---------------------------------------------------------------------------
     * Public API.
     **---------------------------------------------------------------------------
     */
    /**
     * Method returning the renderer's camera.
     *
     * @return {Camera}
     */
    getCamera(): Camera;
    /**
     * Method returning the renderer's graph.
     *
     * @return {Graph}
     */
    getGraph(): Graph;
    /**
     * Method returning the mouse captor.
     *
     * @return {MouseCaptor}
     */
    getMouseCaptor(): MouseCaptor;
    /**
     * Method returning the touch captor.
     *
     * @return {TouchCaptor}
     */
    getTouchCaptor(): TouchCaptor;
    /**
     * Method returning the current renderer's dimensions.
     *
     * @return {Dimensions}
     */
    getDimensions(): Dimensions;
    /**
     * Method returning the current graph's dimensions.
     *
     * @return {Dimensions}
     */
    getGraphDimensions(): Dimensions;
    /**
     * Method used to get all the sigma node attributes.
     * It's usefull for example to get the position of a node
     * and to get values that are set by the nodeReducer
     *
     * @param  {string} key - The node's key.
     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found
     */
    getNodeDisplayData(key: unknown): NodeDisplayData | undefined;
    /**
     * Method used to get all the sigma edge attributes.
     * It's usefull for example to get values that are set by the edgeReducer.
     *
     * @param  {string} key - The edge's key.
     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found
     */
    getEdgeDisplayData(key: unknown): EdgeDisplayData | undefined;
    /**
     * Method returning the current value for a given setting key.
     *
     * @param  {string} key - The setting key to get.
     * @return {any} The value attached to this setting key or undefined if not found
     */
    getSetting<K extends keyof Settings>(key: K): Settings[K] | undefined;
    /**
     * Method setting the value of a given setting key. Note that this will schedule
     * a new render next frame.
     *
     * @param  {string} key - The setting key to set.
     * @param  {any}    value - The value to set.
     * @return {Sigma}
     */
    setSetting<K extends keyof Settings>(key: K, value: Settings[K]): this;
    /**
     * Method updating the value of a given setting key using the provided function.
     * Note that this will schedule a new render next frame.
     *
     * @param  {string}   key     - The setting key to set.
     * @param  {function} updater - The update function.
     * @return {Sigma}
     */
    updateSetting<K extends keyof Settings>(key: K, updater: (value: Settings[K]) => Settings[K]): this;
    /**
     * Method used to resize the renderer.
     *
     * @return {Sigma}
     */
    resize(): this;
    /**
     * Method used to clear all the canvases.
     *
     * @return {Sigma}
     */
    clear(): this;
    /**
     * Method used to refresh all computed data.
     *
     * @return {Sigma}
     */
    refresh(): this;
    /**
     * Method used to refresh all computed data, at the next available frame.
     * If this method has already been called this frame, then it will only render once at the next available frame.
     *
     * @return {Sigma}
     */
    scheduleRefresh(): this;
    /**
     * Method used to (un)zoom, while preserving the position of a viewport point.
     * Used for instance to zoom "on the mouse cursor".
     *
     * @param viewportTarget
     * @param newRatio
     * @return {CameraState}
     */
    getViewportZoomedState(viewportTarget: Coordinates, newRatio: number): CameraState;
    /**
     * Method returning the abstract rectangle containing the graph according
     * to the camera's state.
     *
     * @return {object} - The view's rectangle.
     */
    viewRectangle(): {
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        height: number;
    };
    /**
     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows
     * overriding anything that is used to get the translation matrix, or even the matrix itself.
     *
     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest
     * of computations.
     */
    framedGraphToViewport(coordinates: Coordinates, override?: {
        cameraState?: CameraState;
        matrix?: Float32Array;
        viewportDimensions?: Dimensions;
        graphDimensions?: Dimensions;
        padding?: number;
    }): Coordinates;
    /**
     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows
     * overriding anything that is used to get the translation matrix, or even the matrix itself.
     *
     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest
     * of computations.
     */
    viewportToFramedGraph(coordinates: Coordinates, override?: {
        cameraState?: CameraState;
        matrix?: Float32Array;
        viewportDimensions?: Dimensions;
        graphDimensions?: Dimensions;
        padding?: number;
    }): Coordinates;
    /**
     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the
     * stage) to the graph system (the reference system of data as they are in the given graph instance).
     *
     * This method accepts an optional camera which can be useful if you need to translate coordinates
     * based on a different view than the one being currently being displayed on screen.
     *
     * @param {Coordinates} viewportPoint
     */
    viewportToGraph(viewportPoint: Coordinates): Coordinates;
    /**
     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in
     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).
     *
     * This method accepts an optional camera which can be useful if you need to translate coordinates
     * based on a different view than the one being currently being displayed on screen.
     *
     * @param {Coordinates} graphPoint
     */
    graphToViewport(graphPoint: Coordinates): Coordinates;
    /**
     * Method returning the graph's bounding box.
     *
     * @return {{ x: Extent, y: Extent }}
     */
    getBBox(): {
        x: Extent;
        y: Extent;
    };
    /**
     * Method returning the graph's custom bounding box, if any.
     *
     * @return {{ x: Extent, y: Extent } | null}
     */
    getCustomBBox(): {
        x: Extent;
        y: Extent;
    } | null;
    /**
     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.
     *
     * @return {Sigma}
     */
    setCustomBBox(customBBox: {
        x: Extent;
        y: Extent;
    } | null): this;
    /**
     * Method used to shut the container & release event listeners.
     *
     * @return {undefined}
     */
    kill(): void;
    /**
     * Method used to scale the given size according to the camera's ratio, i.e.
     * zooming state.
     *
     * @param  {number} size - The size to scale (node size, edge thickness etc.).
     * @return {number}      - The scaled size.
     */
    scaleSize(size: number): number;
}
