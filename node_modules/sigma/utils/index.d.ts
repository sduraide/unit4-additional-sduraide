/**
 * Sigma.js Utils
 * ===============
 *
 * Various helper functions & classes used throughout the library.
 * @module
 */
import Graph from "graphology";
import { CameraState, Coordinates, Extent, PlainObject } from "../types";
/**
 * Checks whether the given value is a plain object.
 *
 * @param  {mixed}   value - Target value.
 * @return {boolean}
 */
export declare function isPlainObject(value: any): boolean;
/**
 * Very simple recursive Object.assign-like function.
 *
 * @param  {object} target       - First object.
 * @param  {object} [...objects] - Objects to merge.
 * @return {object}
 */
export declare function assignDeep<T>(target: Partial<T> | undefined, ...objects: Array<Partial<T | undefined>>): T;
/**
 * Just some dirty trick to make requestAnimationFrame and cancelAnimationFrame "work" in Node.js, for unit tests:
 */
export declare const requestFrame: (callback: FrameRequestCallback) => number;
export declare const cancelFrame: (requestID: number) => void;
/**
 * Function used to create DOM elements easily.
 *
 * @param  {string} tag        - Tag name of the element to create.
 * @param  {object} style      - Styles map.
 * @param  {object} attributes - Attributes map.
 * @return {HTMLElement}
 */
export declare function createElement<T extends HTMLElement>(tag: string, style?: Partial<CSSStyleDeclaration>, attributes?: PlainObject<string>): T;
/**
 * Function returning the browser's pixel ratio.
 *
 * @return {number}
 */
export declare function getPixelRatio(): number;
/**
 * Factory returning a function normalizing the given node's position & size.
 *
 * @param  {object}   extent  - Extent of the graph.
 * @return {function}
 */
export interface NormalizationFunction {
    (data: Coordinates): Coordinates;
    inverse(data: Coordinates): Coordinates;
    applyTo(data: Coordinates): void;
}
export declare function createNormalizationFunction(extent: {
    x: Extent;
    y: Extent;
}): NormalizationFunction;
/**
 * Function ordering the given elements in reverse z-order so they drawn
 * the correct way.
 *
 * @param  {number}   extent   - [min, max] z values.
 * @param  {function} getter   - Z attribute getter function.
 * @param  {array}    elements - The array to sort.
 * @return {array} - The sorted array.
 */
export declare function zIndexOrdering<T>(extent: Extent, getter: (e: T) => number, elements: Array<T>): Array<T>;
export declare function floatColor(val: string): number;
/**
 * In sigma, the graph is normalized into a [0, 1], [0, 1] square, before being given to the various renderers. This
 * helps dealing with quadtree in particular.
 * But at some point, we need to rescale it so that it takes the best place in the screen, ie. we always want to see two
 * nodes "touching" opposite sides of the graph, with the camera being at its default state.
 *
 * This function determines this ratio.
 */
export declare function getCorrectionRatio(viewportDimensions: {
    width: number;
    height: number;
}, graphDimensions: {
    width: number;
    height: number;
}): number;
/**
 * Function returning a matrix from the current state of the camera.
 */
export declare function matrixFromCamera(state: CameraState, viewportDimensions: {
    width: number;
    height: number;
}, graphDimensions: {
    width: number;
    height: number;
}, padding: number, inverse?: boolean): Float32Array;
/**
 * Function extracting the color at the given pixel.
 */
export declare function extractPixel(gl: WebGLRenderingContext, x: number, y: number, array: Uint8Array): Uint8Array;
/**
 * Function used to know whether given webgl context can use 32 bits indices.
 */
export declare function canUse32BitsIndices(gl: WebGLRenderingContext): boolean;
/**
 * Check if the graph variable is a valid graph, and if sigma can render it.
 */
export declare function validateGraph(graph: Graph): void;
