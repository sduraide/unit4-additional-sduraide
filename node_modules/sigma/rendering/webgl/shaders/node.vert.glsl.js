(()=>{"use strict";var o={d:(n,e)=>{for(var t in e)o.o(e,t)&&!o.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},o:(o,n)=>Object.prototype.hasOwnProperty.call(o,n),r:o=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(o,"__esModule",{value:!0})}},n={};o.r(n),o.d(n,{default:()=>e});const e="attribute vec2 a_position;\nattribute float a_size;\nattribute float a_color;\nattribute float a_angle;\n\nuniform vec2 u_resolution;\nuniform float u_ratio;\nuniform float u_scale;\nuniform mat3 u_matrix;\n\nvarying vec4 color;\nvarying vec2 center;\nvarying float radius;\n\nvoid main() {\n  // Multiply the point size twice:\n  radius = a_size * u_ratio;\n\n  // Scale from [[-1 1] [-1 1]] to the container:\n  vec2 position = (u_matrix * vec3(a_position, 1)).xy;\n  // center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);\n  center = position * u_scale;\n  center = vec2(center.x, u_scale * u_resolution.y - center.y);\n\n  position = position +\n    2.0 * radius * vec2(cos(a_angle), sin(a_angle));\n  position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);\n\n  radius = radius * u_scale;\n\n  gl_Position = vec4(position, 0, 1);\n\n  // Extract the color:\n  float c = a_color;\n  color.b = mod(c, 256.0); c = floor(c / 256.0);\n  color.g = mod(c, 256.0); c = floor(c / 256.0);\n  color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;\n  color.a = 1.0;\n}\n";module.exports=n})();